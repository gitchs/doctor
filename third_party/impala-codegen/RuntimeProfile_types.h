/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef RuntimeProfile_TYPES_H
#define RuntimeProfile_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <functional>
#include <memory>
#include "ExecStats_types.h"
#include "Metrics_types.h"
#include "Types_types.h"


namespace impala {

struct TRuntimeProfileFormat {
  enum type {
    STRING = 0,
    BASE64 = 1,
    THRIFT = 2,
    JSON = 3
  };
};

extern const std::map<int, const char*> _TRuntimeProfileFormat_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TRuntimeProfileFormat::type& val);

std::string to_string(const TRuntimeProfileFormat::type& val);

class TCounter;

class TAggCounter;

class TEventSequence;

class TAggEventSequence;

class TTimeSeriesCounter;

class TAggTimeSeriesCounter;

class TSummaryStatsCounter;

class TAggSummaryStatsCounter;

class TRuntimeProfileNodeMetadata;

class TAggregatedRuntimeProfileNode;

class TRuntimeProfileNode;

class TRuntimeProfileTree;

class TRuntimeProfileForest;


class TCounter : public virtual ::apache::thrift::TBase {
 public:

  TCounter(const TCounter&);
  TCounter& operator=(const TCounter&);
  TCounter() noexcept
           : name(),
             unit(static_cast< ::impala::TUnit::type>(0)),
             value(0) {
  }

  virtual ~TCounter() noexcept;
  std::string name;
  /**
   * 
   * @see org.apache.impala.thrift.TUnit
   */
   ::impala::TUnit::type unit;
  int64_t value;

  void __set_name(const std::string& val);

  void __set_unit(const  ::impala::TUnit::type val);

  void __set_value(const int64_t val);

  bool operator == (const TCounter & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(unit == rhs.unit))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TCounter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCounter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCounter &a, TCounter &b);

std::ostream& operator<<(std::ostream& out, const TCounter& obj);


class TAggCounter : public virtual ::apache::thrift::TBase {
 public:

  TAggCounter(const TAggCounter&);
  TAggCounter& operator=(const TAggCounter&);
  TAggCounter() noexcept
              : name(),
                unit(static_cast< ::impala::TUnit::type>(0)) {
  }

  virtual ~TAggCounter() noexcept;
  std::string name;
  /**
   * 
   * @see org.apache.impala.thrift.TUnit
   */
   ::impala::TUnit::type unit;
  std::vector<bool>  has_value;
  std::vector<int64_t>  values;

  void __set_name(const std::string& val);

  void __set_unit(const  ::impala::TUnit::type val);

  void __set_has_value(const std::vector<bool> & val);

  void __set_values(const std::vector<int64_t> & val);

  bool operator == (const TAggCounter & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(unit == rhs.unit))
      return false;
    if (!(has_value == rhs.has_value))
      return false;
    if (!(values == rhs.values))
      return false;
    return true;
  }
  bool operator != (const TAggCounter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAggCounter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAggCounter &a, TAggCounter &b);

std::ostream& operator<<(std::ostream& out, const TAggCounter& obj);


class TEventSequence : public virtual ::apache::thrift::TBase {
 public:

  TEventSequence(const TEventSequence&);
  TEventSequence& operator=(const TEventSequence&);
  TEventSequence() noexcept
                 : name() {
  }

  virtual ~TEventSequence() noexcept;
  std::string name;
  std::vector<int64_t>  timestamps;
  std::vector<std::string>  labels;

  void __set_name(const std::string& val);

  void __set_timestamps(const std::vector<int64_t> & val);

  void __set_labels(const std::vector<std::string> & val);

  bool operator == (const TEventSequence & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(timestamps == rhs.timestamps))
      return false;
    if (!(labels == rhs.labels))
      return false;
    return true;
  }
  bool operator != (const TEventSequence &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TEventSequence & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TEventSequence &a, TEventSequence &b);

std::ostream& operator<<(std::ostream& out, const TEventSequence& obj);


class TAggEventSequence : public virtual ::apache::thrift::TBase {
 public:

  TAggEventSequence(const TAggEventSequence&);
  TAggEventSequence& operator=(const TAggEventSequence&);
  TAggEventSequence() noexcept
                    : name() {
  }

  virtual ~TAggEventSequence() noexcept;
  std::string name;
  std::vector<std::string>  label_dict;
  std::vector<std::vector<int32_t> >  label_idxs;
  std::vector<std::vector<int64_t> >  timestamps;

  void __set_name(const std::string& val);

  void __set_label_dict(const std::vector<std::string> & val);

  void __set_label_idxs(const std::vector<std::vector<int32_t> > & val);

  void __set_timestamps(const std::vector<std::vector<int64_t> > & val);

  bool operator == (const TAggEventSequence & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(label_dict == rhs.label_dict))
      return false;
    if (!(label_idxs == rhs.label_idxs))
      return false;
    if (!(timestamps == rhs.timestamps))
      return false;
    return true;
  }
  bool operator != (const TAggEventSequence &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAggEventSequence & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAggEventSequence &a, TAggEventSequence &b);

std::ostream& operator<<(std::ostream& out, const TAggEventSequence& obj);

typedef struct _TTimeSeriesCounter__isset {
  _TTimeSeriesCounter__isset() : start_index(false) {}
  bool start_index :1;
} _TTimeSeriesCounter__isset;

class TTimeSeriesCounter : public virtual ::apache::thrift::TBase {
 public:

  TTimeSeriesCounter(const TTimeSeriesCounter&);
  TTimeSeriesCounter& operator=(const TTimeSeriesCounter&);
  TTimeSeriesCounter() noexcept
                     : name(),
                       unit(static_cast< ::impala::TUnit::type>(0)),
                       period_ms(0),
                       start_index(0) {
  }

  virtual ~TTimeSeriesCounter() noexcept;
  std::string name;
  /**
   * 
   * @see org.apache.impala.thrift.TUnit
   */
   ::impala::TUnit::type unit;
  int32_t period_ms;
  std::vector<int64_t>  values;
  int64_t start_index;

  _TTimeSeriesCounter__isset __isset;

  void __set_name(const std::string& val);

  void __set_unit(const  ::impala::TUnit::type val);

  void __set_period_ms(const int32_t val);

  void __set_values(const std::vector<int64_t> & val);

  void __set_start_index(const int64_t val);

  bool operator == (const TTimeSeriesCounter & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(unit == rhs.unit))
      return false;
    if (!(period_ms == rhs.period_ms))
      return false;
    if (!(values == rhs.values))
      return false;
    if (__isset.start_index != rhs.__isset.start_index)
      return false;
    else if (__isset.start_index && !(start_index == rhs.start_index))
      return false;
    return true;
  }
  bool operator != (const TTimeSeriesCounter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTimeSeriesCounter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTimeSeriesCounter &a, TTimeSeriesCounter &b);

std::ostream& operator<<(std::ostream& out, const TTimeSeriesCounter& obj);


class TAggTimeSeriesCounter : public virtual ::apache::thrift::TBase {
 public:

  TAggTimeSeriesCounter(const TAggTimeSeriesCounter&);
  TAggTimeSeriesCounter& operator=(const TAggTimeSeriesCounter&);
  TAggTimeSeriesCounter() noexcept
                        : name(),
                          unit(static_cast< ::impala::TUnit::type>(0)) {
  }

  virtual ~TAggTimeSeriesCounter() noexcept;
  std::string name;
  /**
   * 
   * @see org.apache.impala.thrift.TUnit
   */
   ::impala::TUnit::type unit;
  std::vector<int32_t>  period_ms;
  std::vector<std::vector<int64_t> >  values;
  std::vector<int64_t>  start_index;

  void __set_name(const std::string& val);

  void __set_unit(const  ::impala::TUnit::type val);

  void __set_period_ms(const std::vector<int32_t> & val);

  void __set_values(const std::vector<std::vector<int64_t> > & val);

  void __set_start_index(const std::vector<int64_t> & val);

  bool operator == (const TAggTimeSeriesCounter & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(unit == rhs.unit))
      return false;
    if (!(period_ms == rhs.period_ms))
      return false;
    if (!(values == rhs.values))
      return false;
    if (!(start_index == rhs.start_index))
      return false;
    return true;
  }
  bool operator != (const TAggTimeSeriesCounter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAggTimeSeriesCounter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAggTimeSeriesCounter &a, TAggTimeSeriesCounter &b);

std::ostream& operator<<(std::ostream& out, const TAggTimeSeriesCounter& obj);


class TSummaryStatsCounter : public virtual ::apache::thrift::TBase {
 public:

  TSummaryStatsCounter(const TSummaryStatsCounter&);
  TSummaryStatsCounter& operator=(const TSummaryStatsCounter&);
  TSummaryStatsCounter() noexcept
                       : name(),
                         unit(static_cast< ::impala::TUnit::type>(0)),
                         sum(0),
                         total_num_values(0),
                         min_value(0),
                         max_value(0) {
  }

  virtual ~TSummaryStatsCounter() noexcept;
  std::string name;
  /**
   * 
   * @see org.apache.impala.thrift.TUnit
   */
   ::impala::TUnit::type unit;
  int64_t sum;
  int64_t total_num_values;
  int64_t min_value;
  int64_t max_value;

  void __set_name(const std::string& val);

  void __set_unit(const  ::impala::TUnit::type val);

  void __set_sum(const int64_t val);

  void __set_total_num_values(const int64_t val);

  void __set_min_value(const int64_t val);

  void __set_max_value(const int64_t val);

  bool operator == (const TSummaryStatsCounter & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(unit == rhs.unit))
      return false;
    if (!(sum == rhs.sum))
      return false;
    if (!(total_num_values == rhs.total_num_values))
      return false;
    if (!(min_value == rhs.min_value))
      return false;
    if (!(max_value == rhs.max_value))
      return false;
    return true;
  }
  bool operator != (const TSummaryStatsCounter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSummaryStatsCounter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSummaryStatsCounter &a, TSummaryStatsCounter &b);

std::ostream& operator<<(std::ostream& out, const TSummaryStatsCounter& obj);


class TAggSummaryStatsCounter : public virtual ::apache::thrift::TBase {
 public:

  TAggSummaryStatsCounter(const TAggSummaryStatsCounter&);
  TAggSummaryStatsCounter& operator=(const TAggSummaryStatsCounter&);
  TAggSummaryStatsCounter() noexcept
                          : name(),
                            unit(static_cast< ::impala::TUnit::type>(0)) {
  }

  virtual ~TAggSummaryStatsCounter() noexcept;
  std::string name;
  /**
   * 
   * @see org.apache.impala.thrift.TUnit
   */
   ::impala::TUnit::type unit;
  std::vector<bool>  has_value;
  std::vector<int64_t>  sum;
  std::vector<int64_t>  total_num_values;
  std::vector<int64_t>  min_value;
  std::vector<int64_t>  max_value;

  void __set_name(const std::string& val);

  void __set_unit(const  ::impala::TUnit::type val);

  void __set_has_value(const std::vector<bool> & val);

  void __set_sum(const std::vector<int64_t> & val);

  void __set_total_num_values(const std::vector<int64_t> & val);

  void __set_min_value(const std::vector<int64_t> & val);

  void __set_max_value(const std::vector<int64_t> & val);

  bool operator == (const TAggSummaryStatsCounter & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(unit == rhs.unit))
      return false;
    if (!(has_value == rhs.has_value))
      return false;
    if (!(sum == rhs.sum))
      return false;
    if (!(total_num_values == rhs.total_num_values))
      return false;
    if (!(min_value == rhs.min_value))
      return false;
    if (!(max_value == rhs.max_value))
      return false;
    return true;
  }
  bool operator != (const TAggSummaryStatsCounter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAggSummaryStatsCounter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAggSummaryStatsCounter &a, TAggSummaryStatsCounter &b);

std::ostream& operator<<(std::ostream& out, const TAggSummaryStatsCounter& obj);

typedef struct _TRuntimeProfileNodeMetadata__isset {
  _TRuntimeProfileNodeMetadata__isset() : plan_node_id(false), data_sink_id(false) {}
  bool plan_node_id :1;
  bool data_sink_id :1;
} _TRuntimeProfileNodeMetadata__isset;

class TRuntimeProfileNodeMetadata : public virtual ::apache::thrift::TBase {
 public:

  TRuntimeProfileNodeMetadata(const TRuntimeProfileNodeMetadata&) noexcept;
  TRuntimeProfileNodeMetadata& operator=(const TRuntimeProfileNodeMetadata&) noexcept;
  TRuntimeProfileNodeMetadata() noexcept
                              : plan_node_id(0),
                                data_sink_id(0) {
  }

  virtual ~TRuntimeProfileNodeMetadata() noexcept;
   ::impala::TPlanNodeId plan_node_id;
   ::impala::TDataSinkId data_sink_id;

  _TRuntimeProfileNodeMetadata__isset __isset;

  void __set_plan_node_id(const  ::impala::TPlanNodeId val);

  void __set_data_sink_id(const  ::impala::TDataSinkId val);

  bool operator == (const TRuntimeProfileNodeMetadata & rhs) const
  {
    if (__isset.plan_node_id != rhs.__isset.plan_node_id)
      return false;
    else if (__isset.plan_node_id && !(plan_node_id == rhs.plan_node_id))
      return false;
    if (__isset.data_sink_id != rhs.__isset.data_sink_id)
      return false;
    else if (__isset.data_sink_id && !(data_sink_id == rhs.data_sink_id))
      return false;
    return true;
  }
  bool operator != (const TRuntimeProfileNodeMetadata &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRuntimeProfileNodeMetadata & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRuntimeProfileNodeMetadata &a, TRuntimeProfileNodeMetadata &b);

std::ostream& operator<<(std::ostream& out, const TRuntimeProfileNodeMetadata& obj);

typedef struct _TAggregatedRuntimeProfileNode__isset {
  _TAggregatedRuntimeProfileNode__isset() : num_instances(false), input_profiles(false), counters(false), info_strings(false), summary_stats_counters(false), event_sequences(false), time_series_counters(false) {}
  bool num_instances :1;
  bool input_profiles :1;
  bool counters :1;
  bool info_strings :1;
  bool summary_stats_counters :1;
  bool event_sequences :1;
  bool time_series_counters :1;
} _TAggregatedRuntimeProfileNode__isset;

class TAggregatedRuntimeProfileNode : public virtual ::apache::thrift::TBase {
 public:

  TAggregatedRuntimeProfileNode(const TAggregatedRuntimeProfileNode&);
  TAggregatedRuntimeProfileNode& operator=(const TAggregatedRuntimeProfileNode&);
  TAggregatedRuntimeProfileNode() noexcept
                                : num_instances(0) {
  }

  virtual ~TAggregatedRuntimeProfileNode() noexcept;
  int32_t num_instances;
  std::vector<std::string>  input_profiles;
  std::vector<TAggCounter>  counters;
  std::map<std::string, std::map<std::string, std::vector<int32_t> > >  info_strings;
  std::vector<TAggSummaryStatsCounter>  summary_stats_counters;
  std::vector<TAggEventSequence>  event_sequences;
  std::vector<TAggTimeSeriesCounter>  time_series_counters;

  _TAggregatedRuntimeProfileNode__isset __isset;

  void __set_num_instances(const int32_t val);

  void __set_input_profiles(const std::vector<std::string> & val);

  void __set_counters(const std::vector<TAggCounter> & val);

  void __set_info_strings(const std::map<std::string, std::map<std::string, std::vector<int32_t> > > & val);

  void __set_summary_stats_counters(const std::vector<TAggSummaryStatsCounter> & val);

  void __set_event_sequences(const std::vector<TAggEventSequence> & val);

  void __set_time_series_counters(const std::vector<TAggTimeSeriesCounter> & val);

  bool operator == (const TAggregatedRuntimeProfileNode & rhs) const
  {
    if (__isset.num_instances != rhs.__isset.num_instances)
      return false;
    else if (__isset.num_instances && !(num_instances == rhs.num_instances))
      return false;
    if (__isset.input_profiles != rhs.__isset.input_profiles)
      return false;
    else if (__isset.input_profiles && !(input_profiles == rhs.input_profiles))
      return false;
    if (__isset.counters != rhs.__isset.counters)
      return false;
    else if (__isset.counters && !(counters == rhs.counters))
      return false;
    if (__isset.info_strings != rhs.__isset.info_strings)
      return false;
    else if (__isset.info_strings && !(info_strings == rhs.info_strings))
      return false;
    if (__isset.summary_stats_counters != rhs.__isset.summary_stats_counters)
      return false;
    else if (__isset.summary_stats_counters && !(summary_stats_counters == rhs.summary_stats_counters))
      return false;
    if (__isset.event_sequences != rhs.__isset.event_sequences)
      return false;
    else if (__isset.event_sequences && !(event_sequences == rhs.event_sequences))
      return false;
    if (__isset.time_series_counters != rhs.__isset.time_series_counters)
      return false;
    else if (__isset.time_series_counters && !(time_series_counters == rhs.time_series_counters))
      return false;
    return true;
  }
  bool operator != (const TAggregatedRuntimeProfileNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAggregatedRuntimeProfileNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAggregatedRuntimeProfileNode &a, TAggregatedRuntimeProfileNode &b);

std::ostream& operator<<(std::ostream& out, const TAggregatedRuntimeProfileNode& obj);

typedef struct _TRuntimeProfileNode__isset {
  _TRuntimeProfileNode__isset() : event_sequences(false), time_series_counters(false), summary_stats_counters(false), node_metadata(false), aggregated(false) {}
  bool event_sequences :1;
  bool time_series_counters :1;
  bool summary_stats_counters :1;
  bool node_metadata :1;
  bool aggregated :1;
} _TRuntimeProfileNode__isset;

class TRuntimeProfileNode : public virtual ::apache::thrift::TBase {
 public:

  TRuntimeProfileNode(const TRuntimeProfileNode&);
  TRuntimeProfileNode& operator=(const TRuntimeProfileNode&);
  TRuntimeProfileNode() noexcept
                      : name(),
                        num_children(0),
                        metadata(0),
                        indent(0) {
  }

  virtual ~TRuntimeProfileNode() noexcept;
  std::string name;
  int32_t num_children;
  std::vector<TCounter>  counters;
  int64_t metadata;
  bool indent;
  std::map<std::string, std::string>  info_strings;
  std::vector<std::string>  info_strings_display_order;
  std::map<std::string, std::set<std::string> >  child_counters_map;
  std::vector<TEventSequence>  event_sequences;
  std::vector<TTimeSeriesCounter>  time_series_counters;
  std::vector<TSummaryStatsCounter>  summary_stats_counters;
  TRuntimeProfileNodeMetadata node_metadata;
  TAggregatedRuntimeProfileNode aggregated;

  _TRuntimeProfileNode__isset __isset;

  void __set_name(const std::string& val);

  void __set_num_children(const int32_t val);

  void __set_counters(const std::vector<TCounter> & val);

  void __set_metadata(const int64_t val);

  void __set_indent(const bool val);

  void __set_info_strings(const std::map<std::string, std::string> & val);

  void __set_info_strings_display_order(const std::vector<std::string> & val);

  void __set_child_counters_map(const std::map<std::string, std::set<std::string> > & val);

  void __set_event_sequences(const std::vector<TEventSequence> & val);

  void __set_time_series_counters(const std::vector<TTimeSeriesCounter> & val);

  void __set_summary_stats_counters(const std::vector<TSummaryStatsCounter> & val);

  void __set_node_metadata(const TRuntimeProfileNodeMetadata& val);

  void __set_aggregated(const TAggregatedRuntimeProfileNode& val);

  bool operator == (const TRuntimeProfileNode & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(num_children == rhs.num_children))
      return false;
    if (!(counters == rhs.counters))
      return false;
    if (!(metadata == rhs.metadata))
      return false;
    if (!(indent == rhs.indent))
      return false;
    if (!(info_strings == rhs.info_strings))
      return false;
    if (!(info_strings_display_order == rhs.info_strings_display_order))
      return false;
    if (!(child_counters_map == rhs.child_counters_map))
      return false;
    if (__isset.event_sequences != rhs.__isset.event_sequences)
      return false;
    else if (__isset.event_sequences && !(event_sequences == rhs.event_sequences))
      return false;
    if (__isset.time_series_counters != rhs.__isset.time_series_counters)
      return false;
    else if (__isset.time_series_counters && !(time_series_counters == rhs.time_series_counters))
      return false;
    if (__isset.summary_stats_counters != rhs.__isset.summary_stats_counters)
      return false;
    else if (__isset.summary_stats_counters && !(summary_stats_counters == rhs.summary_stats_counters))
      return false;
    if (__isset.node_metadata != rhs.__isset.node_metadata)
      return false;
    else if (__isset.node_metadata && !(node_metadata == rhs.node_metadata))
      return false;
    if (__isset.aggregated != rhs.__isset.aggregated)
      return false;
    else if (__isset.aggregated && !(aggregated == rhs.aggregated))
      return false;
    return true;
  }
  bool operator != (const TRuntimeProfileNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRuntimeProfileNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRuntimeProfileNode &a, TRuntimeProfileNode &b);

std::ostream& operator<<(std::ostream& out, const TRuntimeProfileNode& obj);

typedef struct _TRuntimeProfileTree__isset {
  _TRuntimeProfileTree__isset() : exec_summary(false), profile_version(false) {}
  bool exec_summary :1;
  bool profile_version :1;
} _TRuntimeProfileTree__isset;

class TRuntimeProfileTree : public virtual ::apache::thrift::TBase {
 public:

  TRuntimeProfileTree(const TRuntimeProfileTree&);
  TRuntimeProfileTree& operator=(const TRuntimeProfileTree&);
  TRuntimeProfileTree() noexcept
                      : profile_version(0) {
  }

  virtual ~TRuntimeProfileTree() noexcept;
  std::vector<TRuntimeProfileNode>  nodes;
   ::impala::TExecSummary exec_summary;
  int32_t profile_version;

  _TRuntimeProfileTree__isset __isset;

  void __set_nodes(const std::vector<TRuntimeProfileNode> & val);

  void __set_exec_summary(const  ::impala::TExecSummary& val);

  void __set_profile_version(const int32_t val);

  bool operator == (const TRuntimeProfileTree & rhs) const
  {
    if (!(nodes == rhs.nodes))
      return false;
    if (__isset.exec_summary != rhs.__isset.exec_summary)
      return false;
    else if (__isset.exec_summary && !(exec_summary == rhs.exec_summary))
      return false;
    if (__isset.profile_version != rhs.__isset.profile_version)
      return false;
    else if (__isset.profile_version && !(profile_version == rhs.profile_version))
      return false;
    return true;
  }
  bool operator != (const TRuntimeProfileTree &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRuntimeProfileTree & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRuntimeProfileTree &a, TRuntimeProfileTree &b);

std::ostream& operator<<(std::ostream& out, const TRuntimeProfileTree& obj);

typedef struct _TRuntimeProfileForest__isset {
  _TRuntimeProfileForest__isset() : host_profile(false) {}
  bool host_profile :1;
} _TRuntimeProfileForest__isset;

class TRuntimeProfileForest : public virtual ::apache::thrift::TBase {
 public:

  TRuntimeProfileForest(const TRuntimeProfileForest&);
  TRuntimeProfileForest& operator=(const TRuntimeProfileForest&);
  TRuntimeProfileForest() noexcept {
  }

  virtual ~TRuntimeProfileForest() noexcept;
  std::vector<TRuntimeProfileTree>  profile_trees;
  TRuntimeProfileTree host_profile;

  _TRuntimeProfileForest__isset __isset;

  void __set_profile_trees(const std::vector<TRuntimeProfileTree> & val);

  void __set_host_profile(const TRuntimeProfileTree& val);

  bool operator == (const TRuntimeProfileForest & rhs) const
  {
    if (!(profile_trees == rhs.profile_trees))
      return false;
    if (__isset.host_profile != rhs.__isset.host_profile)
      return false;
    else if (__isset.host_profile && !(host_profile == rhs.host_profile))
      return false;
    return true;
  }
  bool operator != (const TRuntimeProfileForest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRuntimeProfileForest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRuntimeProfileForest &a, TRuntimeProfileForest &b);

std::ostream& operator<<(std::ostream& out, const TRuntimeProfileForest& obj);

} // namespace

#endif
