/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Types_TYPES_H
#define Types_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <functional>
#include <memory>


namespace impala {

struct TPrimitiveType {
  enum type {
    INVALID_TYPE = 0,
    NULL_TYPE = 1,
    BOOLEAN = 2,
    TINYINT = 3,
    SMALLINT = 4,
    INT = 5,
    BIGINT = 6,
    FLOAT = 7,
    DOUBLE = 8,
    DATE = 9,
    DATETIME = 10,
    TIMESTAMP = 11,
    STRING = 12,
    BINARY = 13,
    DECIMAL = 14,
    CHAR = 15,
    VARCHAR = 16,
    FIXED_UDA_INTERMEDIATE = 17
  };
};

extern const std::map<int, const char*> _TPrimitiveType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TPrimitiveType::type& val);

std::string to_string(const TPrimitiveType::type& val);

struct TTypeNodeType {
  enum type {
    SCALAR = 0,
    ARRAY = 1,
    MAP = 2,
    STRUCT = 3
  };
};

extern const std::map<int, const char*> _TTypeNodeType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TTypeNodeType::type& val);

std::string to_string(const TTypeNodeType::type& val);

struct TStmtType {
  enum type {
    QUERY = 0,
    DDL = 1,
    DML = 2,
    EXPLAIN = 3,
    LOAD = 4,
    SET = 5,
    ADMIN_FN = 6,
    TESTCASE = 7
  };
};

extern const std::map<int, const char*> _TStmtType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TStmtType::type& val);

std::string to_string(const TStmtType::type& val);

struct TExplainLevel {
  enum type {
    MINIMAL = 0,
    STANDARD = 1,
    EXTENDED = 2,
    VERBOSE = 3
  };
};

extern const std::map<int, const char*> _TExplainLevel_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TExplainLevel::type& val);

std::string to_string(const TExplainLevel::type& val);

struct TRuntimeFilterMode {
  enum type {
    OFF = 0,
    LOCAL = 1,
    GLOBAL = 2
  };
};

extern const std::map<int, const char*> _TRuntimeFilterMode_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TRuntimeFilterMode::type& val);

std::string to_string(const TRuntimeFilterMode::type& val);

struct TPrefetchMode {
  enum type {
    NONE = 0,
    HT_BUCKET = 1
  };
};

extern const std::map<int, const char*> _TPrefetchMode_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TPrefetchMode::type& val);

std::string to_string(const TPrefetchMode::type& val);

struct TFunctionCategory {
  enum type {
    SCALAR = 0,
    AGGREGATE = 1,
    ANALYTIC = 2
  };
};

extern const std::map<int, const char*> _TFunctionCategory_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TFunctionCategory::type& val);

std::string to_string(const TFunctionCategory::type& val);

struct TFunctionBinaryType {
  enum type {
    BUILTIN = 0,
    JAVA = 1,
    NATIVE = 2,
    IR = 3
  };
};

extern const std::map<int, const char*> _TFunctionBinaryType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TFunctionBinaryType::type& val);

std::string to_string(const TFunctionBinaryType::type& val);

struct TSortingOrder {
  enum type {
    LEXICAL = 0,
    ZORDER = 1
  };
};

extern const std::map<int, const char*> _TSortingOrder_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TSortingOrder::type& val);

std::string to_string(const TSortingOrder::type& val);

typedef int64_t TTimestamp;

typedef int32_t TFragmentIdx;

typedef int32_t TPlanNodeId;

typedef int32_t TDataSinkId;

typedef int32_t TTupleId;

typedef int32_t TSlotId;

typedef int32_t TTableId;

typedef class TUniqueId TBackendId;

class TScalarType;

class TStructField;

class TTypeNode;

class TColumnType;

class TNetworkAddress;

class TUniqueId;

class TFunctionName;

class TScalarFunction;

class TAggregateFunction;

class TFunction;

typedef struct _TScalarType__isset {
  _TScalarType__isset() : len(false), precision(false), scale(false) {}
  bool len :1;
  bool precision :1;
  bool scale :1;
} _TScalarType__isset;

class TScalarType : public virtual ::apache::thrift::TBase {
 public:

  TScalarType(const TScalarType&) noexcept;
  TScalarType& operator=(const TScalarType&) noexcept;
  TScalarType() noexcept
              : type(static_cast<TPrimitiveType::type>(0)),
                len(0),
                precision(0),
                scale(0) {
  }

  virtual ~TScalarType() noexcept;
  /**
   * 
   * @see TPrimitiveType
   */
  TPrimitiveType::type type;
  int32_t len;
  int32_t precision;
  int32_t scale;

  _TScalarType__isset __isset;

  void __set_type(const TPrimitiveType::type val);

  void __set_len(const int32_t val);

  void __set_precision(const int32_t val);

  void __set_scale(const int32_t val);

  bool operator == (const TScalarType & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (__isset.len != rhs.__isset.len)
      return false;
    else if (__isset.len && !(len == rhs.len))
      return false;
    if (__isset.precision != rhs.__isset.precision)
      return false;
    else if (__isset.precision && !(precision == rhs.precision))
      return false;
    if (__isset.scale != rhs.__isset.scale)
      return false;
    else if (__isset.scale && !(scale == rhs.scale))
      return false;
    return true;
  }
  bool operator != (const TScalarType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TScalarType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TScalarType &a, TScalarType &b);

std::ostream& operator<<(std::ostream& out, const TScalarType& obj);

typedef struct _TStructField__isset {
  _TStructField__isset() : comment(false), field_id(false) {}
  bool comment :1;
  bool field_id :1;
} _TStructField__isset;

class TStructField : public virtual ::apache::thrift::TBase {
 public:

  TStructField(const TStructField&);
  TStructField& operator=(const TStructField&);
  TStructField() noexcept
               : name(),
                 comment(),
                 field_id(0) {
  }

  virtual ~TStructField() noexcept;
  std::string name;
  std::string comment;
  int32_t field_id;

  _TStructField__isset __isset;

  void __set_name(const std::string& val);

  void __set_comment(const std::string& val);

  void __set_field_id(const int32_t val);

  bool operator == (const TStructField & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    if (__isset.field_id != rhs.__isset.field_id)
      return false;
    else if (__isset.field_id && !(field_id == rhs.field_id))
      return false;
    return true;
  }
  bool operator != (const TStructField &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TStructField & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TStructField &a, TStructField &b);

std::ostream& operator<<(std::ostream& out, const TStructField& obj);

typedef struct _TTypeNode__isset {
  _TTypeNode__isset() : scalar_type(false), struct_fields(false) {}
  bool scalar_type :1;
  bool struct_fields :1;
} _TTypeNode__isset;

class TTypeNode : public virtual ::apache::thrift::TBase {
 public:

  TTypeNode(const TTypeNode&);
  TTypeNode& operator=(const TTypeNode&);
  TTypeNode() noexcept
            : type(static_cast<TTypeNodeType::type>(0)) {
  }

  virtual ~TTypeNode() noexcept;
  /**
   * 
   * @see TTypeNodeType
   */
  TTypeNodeType::type type;
  TScalarType scalar_type;
  std::vector<TStructField>  struct_fields;

  _TTypeNode__isset __isset;

  void __set_type(const TTypeNodeType::type val);

  void __set_scalar_type(const TScalarType& val);

  void __set_struct_fields(const std::vector<TStructField> & val);

  bool operator == (const TTypeNode & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (__isset.scalar_type != rhs.__isset.scalar_type)
      return false;
    else if (__isset.scalar_type && !(scalar_type == rhs.scalar_type))
      return false;
    if (__isset.struct_fields != rhs.__isset.struct_fields)
      return false;
    else if (__isset.struct_fields && !(struct_fields == rhs.struct_fields))
      return false;
    return true;
  }
  bool operator != (const TTypeNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTypeNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTypeNode &a, TTypeNode &b);

std::ostream& operator<<(std::ostream& out, const TTypeNode& obj);

typedef struct _TColumnType__isset {
  _TColumnType__isset() : types(false) {}
  bool types :1;
} _TColumnType__isset;

class TColumnType : public virtual ::apache::thrift::TBase {
 public:

  TColumnType(const TColumnType&);
  TColumnType& operator=(const TColumnType&);
  TColumnType() noexcept {
  }

  virtual ~TColumnType() noexcept;
  std::vector<TTypeNode>  types;

  _TColumnType__isset __isset;

  void __set_types(const std::vector<TTypeNode> & val);

  bool operator == (const TColumnType & rhs) const
  {
    if (!(types == rhs.types))
      return false;
    return true;
  }
  bool operator != (const TColumnType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumnType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TColumnType &a, TColumnType &b);

std::ostream& operator<<(std::ostream& out, const TColumnType& obj);


class TNetworkAddress : public virtual ::apache::thrift::TBase {
 public:

  TNetworkAddress(const TNetworkAddress&);
  TNetworkAddress& operator=(const TNetworkAddress&);
  TNetworkAddress() noexcept
                  : hostname(),
                    port(0) {
  }

  virtual ~TNetworkAddress() noexcept;
  std::string hostname;
  int32_t port;

  void __set_hostname(const std::string& val);

  void __set_port(const int32_t val);

  bool operator == (const TNetworkAddress & rhs) const
  {
    if (!(hostname == rhs.hostname))
      return false;
    if (!(port == rhs.port))
      return false;
    return true;
  }
  bool operator != (const TNetworkAddress &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TNetworkAddress & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TNetworkAddress &a, TNetworkAddress &b);

std::ostream& operator<<(std::ostream& out, const TNetworkAddress& obj);


class TUniqueId : public virtual ::apache::thrift::TBase {
 public:

  TUniqueId(const TUniqueId&) noexcept;
  TUniqueId& operator=(const TUniqueId&) noexcept;
  TUniqueId() noexcept
            : hi(0),
              lo(0) {
  }

  virtual ~TUniqueId() noexcept;
  int64_t hi;
  int64_t lo;

  void __set_hi(const int64_t val);

  void __set_lo(const int64_t val);

  bool operator == (const TUniqueId & rhs) const
  {
    if (!(hi == rhs.hi))
      return false;
    if (!(lo == rhs.lo))
      return false;
    return true;
  }
  bool operator != (const TUniqueId &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TUniqueId & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TUniqueId &a, TUniqueId &b);

std::ostream& operator<<(std::ostream& out, const TUniqueId& obj);

typedef struct _TFunctionName__isset {
  _TFunctionName__isset() : db_name(false) {}
  bool db_name :1;
} _TFunctionName__isset;

class TFunctionName : public virtual ::apache::thrift::TBase {
 public:

  TFunctionName(const TFunctionName&);
  TFunctionName& operator=(const TFunctionName&);
  TFunctionName() noexcept
                : db_name(),
                  function_name() {
  }

  virtual ~TFunctionName() noexcept;
  std::string db_name;
  std::string function_name;

  _TFunctionName__isset __isset;

  void __set_db_name(const std::string& val);

  void __set_function_name(const std::string& val);

  bool operator == (const TFunctionName & rhs) const
  {
    if (__isset.db_name != rhs.__isset.db_name)
      return false;
    else if (__isset.db_name && !(db_name == rhs.db_name))
      return false;
    if (!(function_name == rhs.function_name))
      return false;
    return true;
  }
  bool operator != (const TFunctionName &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFunctionName & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TFunctionName &a, TFunctionName &b);

std::ostream& operator<<(std::ostream& out, const TFunctionName& obj);

typedef struct _TScalarFunction__isset {
  _TScalarFunction__isset() : prepare_fn_symbol(false), close_fn_symbol(false) {}
  bool prepare_fn_symbol :1;
  bool close_fn_symbol :1;
} _TScalarFunction__isset;

class TScalarFunction : public virtual ::apache::thrift::TBase {
 public:

  TScalarFunction(const TScalarFunction&);
  TScalarFunction& operator=(const TScalarFunction&);
  TScalarFunction() noexcept
                  : symbol(),
                    prepare_fn_symbol(),
                    close_fn_symbol() {
  }

  virtual ~TScalarFunction() noexcept;
  std::string symbol;
  std::string prepare_fn_symbol;
  std::string close_fn_symbol;

  _TScalarFunction__isset __isset;

  void __set_symbol(const std::string& val);

  void __set_prepare_fn_symbol(const std::string& val);

  void __set_close_fn_symbol(const std::string& val);

  bool operator == (const TScalarFunction & rhs) const
  {
    if (!(symbol == rhs.symbol))
      return false;
    if (__isset.prepare_fn_symbol != rhs.__isset.prepare_fn_symbol)
      return false;
    else if (__isset.prepare_fn_symbol && !(prepare_fn_symbol == rhs.prepare_fn_symbol))
      return false;
    if (__isset.close_fn_symbol != rhs.__isset.close_fn_symbol)
      return false;
    else if (__isset.close_fn_symbol && !(close_fn_symbol == rhs.close_fn_symbol))
      return false;
    return true;
  }
  bool operator != (const TScalarFunction &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TScalarFunction & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TScalarFunction &a, TScalarFunction &b);

std::ostream& operator<<(std::ostream& out, const TScalarFunction& obj);

typedef struct _TAggregateFunction__isset {
  _TAggregateFunction__isset() : serialize_fn_symbol(false), merge_fn_symbol(false), finalize_fn_symbol(false), get_value_fn_symbol(false), remove_fn_symbol(false), ignores_distinct(false) {}
  bool serialize_fn_symbol :1;
  bool merge_fn_symbol :1;
  bool finalize_fn_symbol :1;
  bool get_value_fn_symbol :1;
  bool remove_fn_symbol :1;
  bool ignores_distinct :1;
} _TAggregateFunction__isset;

class TAggregateFunction : public virtual ::apache::thrift::TBase {
 public:

  TAggregateFunction(const TAggregateFunction&);
  TAggregateFunction& operator=(const TAggregateFunction&);
  TAggregateFunction() noexcept
                     : is_analytic_only_fn(0),
                       update_fn_symbol(),
                       init_fn_symbol(),
                       serialize_fn_symbol(),
                       merge_fn_symbol(),
                       finalize_fn_symbol(),
                       get_value_fn_symbol(),
                       remove_fn_symbol(),
                       ignores_distinct(0) {
  }

  virtual ~TAggregateFunction() noexcept;
  TColumnType intermediate_type;
  bool is_analytic_only_fn;
  std::string update_fn_symbol;
  std::string init_fn_symbol;
  std::string serialize_fn_symbol;
  std::string merge_fn_symbol;
  std::string finalize_fn_symbol;
  std::string get_value_fn_symbol;
  std::string remove_fn_symbol;
  bool ignores_distinct;

  _TAggregateFunction__isset __isset;

  void __set_intermediate_type(const TColumnType& val);

  void __set_is_analytic_only_fn(const bool val);

  void __set_update_fn_symbol(const std::string& val);

  void __set_init_fn_symbol(const std::string& val);

  void __set_serialize_fn_symbol(const std::string& val);

  void __set_merge_fn_symbol(const std::string& val);

  void __set_finalize_fn_symbol(const std::string& val);

  void __set_get_value_fn_symbol(const std::string& val);

  void __set_remove_fn_symbol(const std::string& val);

  void __set_ignores_distinct(const bool val);

  bool operator == (const TAggregateFunction & rhs) const
  {
    if (!(intermediate_type == rhs.intermediate_type))
      return false;
    if (!(is_analytic_only_fn == rhs.is_analytic_only_fn))
      return false;
    if (!(update_fn_symbol == rhs.update_fn_symbol))
      return false;
    if (!(init_fn_symbol == rhs.init_fn_symbol))
      return false;
    if (__isset.serialize_fn_symbol != rhs.__isset.serialize_fn_symbol)
      return false;
    else if (__isset.serialize_fn_symbol && !(serialize_fn_symbol == rhs.serialize_fn_symbol))
      return false;
    if (__isset.merge_fn_symbol != rhs.__isset.merge_fn_symbol)
      return false;
    else if (__isset.merge_fn_symbol && !(merge_fn_symbol == rhs.merge_fn_symbol))
      return false;
    if (__isset.finalize_fn_symbol != rhs.__isset.finalize_fn_symbol)
      return false;
    else if (__isset.finalize_fn_symbol && !(finalize_fn_symbol == rhs.finalize_fn_symbol))
      return false;
    if (__isset.get_value_fn_symbol != rhs.__isset.get_value_fn_symbol)
      return false;
    else if (__isset.get_value_fn_symbol && !(get_value_fn_symbol == rhs.get_value_fn_symbol))
      return false;
    if (__isset.remove_fn_symbol != rhs.__isset.remove_fn_symbol)
      return false;
    else if (__isset.remove_fn_symbol && !(remove_fn_symbol == rhs.remove_fn_symbol))
      return false;
    if (__isset.ignores_distinct != rhs.__isset.ignores_distinct)
      return false;
    else if (__isset.ignores_distinct && !(ignores_distinct == rhs.ignores_distinct))
      return false;
    return true;
  }
  bool operator != (const TAggregateFunction &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAggregateFunction & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAggregateFunction &a, TAggregateFunction &b);

std::ostream& operator<<(std::ostream& out, const TAggregateFunction& obj);

typedef struct _TFunction__isset {
  _TFunction__isset() : binary_type(false), arg_types(false), ret_type(false), has_var_args(false), comment(false), signature(false), hdfs_location(false), scalar_fn(false), aggregate_fn(false), is_persistent(false), last_modified_time(false) {}
  bool binary_type :1;
  bool arg_types :1;
  bool ret_type :1;
  bool has_var_args :1;
  bool comment :1;
  bool signature :1;
  bool hdfs_location :1;
  bool scalar_fn :1;
  bool aggregate_fn :1;
  bool is_persistent :1;
  bool last_modified_time :1;
} _TFunction__isset;

class TFunction : public virtual ::apache::thrift::TBase {
 public:

  TFunction(const TFunction&);
  TFunction& operator=(const TFunction&);
  TFunction() noexcept
            : binary_type(static_cast<TFunctionBinaryType::type>(0)),
              has_var_args(0),
              comment(),
              signature(),
              hdfs_location(),
              is_persistent(0),
              last_modified_time(0) {
  }

  virtual ~TFunction() noexcept;
  TFunctionName name;
  /**
   * 
   * @see TFunctionBinaryType
   */
  TFunctionBinaryType::type binary_type;
  std::vector<TColumnType>  arg_types;
  TColumnType ret_type;
  bool has_var_args;
  std::string comment;
  std::string signature;
  std::string hdfs_location;
  TScalarFunction scalar_fn;
  TAggregateFunction aggregate_fn;
  bool is_persistent;
  int64_t last_modified_time;

  _TFunction__isset __isset;

  void __set_name(const TFunctionName& val);

  void __set_binary_type(const TFunctionBinaryType::type val);

  void __set_arg_types(const std::vector<TColumnType> & val);

  void __set_ret_type(const TColumnType& val);

  void __set_has_var_args(const bool val);

  void __set_comment(const std::string& val);

  void __set_signature(const std::string& val);

  void __set_hdfs_location(const std::string& val);

  void __set_scalar_fn(const TScalarFunction& val);

  void __set_aggregate_fn(const TAggregateFunction& val);

  void __set_is_persistent(const bool val);

  void __set_last_modified_time(const int64_t val);

  bool operator == (const TFunction & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.binary_type != rhs.__isset.binary_type)
      return false;
    else if (__isset.binary_type && !(binary_type == rhs.binary_type))
      return false;
    if (__isset.arg_types != rhs.__isset.arg_types)
      return false;
    else if (__isset.arg_types && !(arg_types == rhs.arg_types))
      return false;
    if (__isset.ret_type != rhs.__isset.ret_type)
      return false;
    else if (__isset.ret_type && !(ret_type == rhs.ret_type))
      return false;
    if (__isset.has_var_args != rhs.__isset.has_var_args)
      return false;
    else if (__isset.has_var_args && !(has_var_args == rhs.has_var_args))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    if (__isset.signature != rhs.__isset.signature)
      return false;
    else if (__isset.signature && !(signature == rhs.signature))
      return false;
    if (__isset.hdfs_location != rhs.__isset.hdfs_location)
      return false;
    else if (__isset.hdfs_location && !(hdfs_location == rhs.hdfs_location))
      return false;
    if (__isset.scalar_fn != rhs.__isset.scalar_fn)
      return false;
    else if (__isset.scalar_fn && !(scalar_fn == rhs.scalar_fn))
      return false;
    if (__isset.aggregate_fn != rhs.__isset.aggregate_fn)
      return false;
    else if (__isset.aggregate_fn && !(aggregate_fn == rhs.aggregate_fn))
      return false;
    if (__isset.is_persistent != rhs.__isset.is_persistent)
      return false;
    else if (__isset.is_persistent && !(is_persistent == rhs.is_persistent))
      return false;
    if (__isset.last_modified_time != rhs.__isset.last_modified_time)
      return false;
    else if (__isset.last_modified_time && !(last_modified_time == rhs.last_modified_time))
      return false;
    return true;
  }
  bool operator != (const TFunction &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFunction & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TFunction &a, TFunction &b);

std::ostream& operator<<(std::ostream& out, const TFunction& obj);

} // namespace

#endif
