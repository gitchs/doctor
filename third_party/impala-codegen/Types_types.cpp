/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Types_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace impala {

int _kTPrimitiveTypeValues[] = {
  TPrimitiveType::INVALID_TYPE,
  TPrimitiveType::NULL_TYPE,
  TPrimitiveType::BOOLEAN,
  TPrimitiveType::TINYINT,
  TPrimitiveType::SMALLINT,
  TPrimitiveType::INT,
  TPrimitiveType::BIGINT,
  TPrimitiveType::FLOAT,
  TPrimitiveType::DOUBLE,
  TPrimitiveType::DATE,
  TPrimitiveType::DATETIME,
  TPrimitiveType::TIMESTAMP,
  TPrimitiveType::STRING,
  TPrimitiveType::BINARY,
  TPrimitiveType::DECIMAL,
  TPrimitiveType::CHAR,
  TPrimitiveType::VARCHAR,
  TPrimitiveType::FIXED_UDA_INTERMEDIATE
};
const char* _kTPrimitiveTypeNames[] = {
  "INVALID_TYPE",
  "NULL_TYPE",
  "BOOLEAN",
  "TINYINT",
  "SMALLINT",
  "INT",
  "BIGINT",
  "FLOAT",
  "DOUBLE",
  "DATE",
  "DATETIME",
  "TIMESTAMP",
  "STRING",
  "BINARY",
  "DECIMAL",
  "CHAR",
  "VARCHAR",
  "FIXED_UDA_INTERMEDIATE"
};
const std::map<int, const char*> _TPrimitiveType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(18, _kTPrimitiveTypeValues, _kTPrimitiveTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TPrimitiveType::type& val) {
  std::map<int, const char*>::const_iterator it = _TPrimitiveType_VALUES_TO_NAMES.find(val);
  if (it != _TPrimitiveType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TPrimitiveType::type& val) {
  std::map<int, const char*>::const_iterator it = _TPrimitiveType_VALUES_TO_NAMES.find(val);
  if (it != _TPrimitiveType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTTypeNodeTypeValues[] = {
  TTypeNodeType::SCALAR,
  TTypeNodeType::ARRAY,
  TTypeNodeType::MAP,
  TTypeNodeType::STRUCT
};
const char* _kTTypeNodeTypeNames[] = {
  "SCALAR",
  "ARRAY",
  "MAP",
  "STRUCT"
};
const std::map<int, const char*> _TTypeNodeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTTypeNodeTypeValues, _kTTypeNodeTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TTypeNodeType::type& val) {
  std::map<int, const char*>::const_iterator it = _TTypeNodeType_VALUES_TO_NAMES.find(val);
  if (it != _TTypeNodeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TTypeNodeType::type& val) {
  std::map<int, const char*>::const_iterator it = _TTypeNodeType_VALUES_TO_NAMES.find(val);
  if (it != _TTypeNodeType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTStmtTypeValues[] = {
  TStmtType::QUERY,
  TStmtType::DDL,
  TStmtType::DML,
  TStmtType::EXPLAIN,
  TStmtType::LOAD,
  TStmtType::SET,
  TStmtType::ADMIN_FN,
  TStmtType::TESTCASE
};
const char* _kTStmtTypeNames[] = {
  "QUERY",
  "DDL",
  "DML",
  "EXPLAIN",
  "LOAD",
  "SET",
  "ADMIN_FN",
  "TESTCASE"
};
const std::map<int, const char*> _TStmtType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kTStmtTypeValues, _kTStmtTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TStmtType::type& val) {
  std::map<int, const char*>::const_iterator it = _TStmtType_VALUES_TO_NAMES.find(val);
  if (it != _TStmtType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TStmtType::type& val) {
  std::map<int, const char*>::const_iterator it = _TStmtType_VALUES_TO_NAMES.find(val);
  if (it != _TStmtType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTExplainLevelValues[] = {
  TExplainLevel::MINIMAL,
  TExplainLevel::STANDARD,
  TExplainLevel::EXTENDED,
  TExplainLevel::VERBOSE
};
const char* _kTExplainLevelNames[] = {
  "MINIMAL",
  "STANDARD",
  "EXTENDED",
  "VERBOSE"
};
const std::map<int, const char*> _TExplainLevel_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTExplainLevelValues, _kTExplainLevelNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TExplainLevel::type& val) {
  std::map<int, const char*>::const_iterator it = _TExplainLevel_VALUES_TO_NAMES.find(val);
  if (it != _TExplainLevel_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TExplainLevel::type& val) {
  std::map<int, const char*>::const_iterator it = _TExplainLevel_VALUES_TO_NAMES.find(val);
  if (it != _TExplainLevel_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTRuntimeFilterModeValues[] = {
  TRuntimeFilterMode::OFF,
  TRuntimeFilterMode::LOCAL,
  TRuntimeFilterMode::GLOBAL
};
const char* _kTRuntimeFilterModeNames[] = {
  "OFF",
  "LOCAL",
  "GLOBAL"
};
const std::map<int, const char*> _TRuntimeFilterMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTRuntimeFilterModeValues, _kTRuntimeFilterModeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TRuntimeFilterMode::type& val) {
  std::map<int, const char*>::const_iterator it = _TRuntimeFilterMode_VALUES_TO_NAMES.find(val);
  if (it != _TRuntimeFilterMode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TRuntimeFilterMode::type& val) {
  std::map<int, const char*>::const_iterator it = _TRuntimeFilterMode_VALUES_TO_NAMES.find(val);
  if (it != _TRuntimeFilterMode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTPrefetchModeValues[] = {
  TPrefetchMode::NONE,
  TPrefetchMode::HT_BUCKET
};
const char* _kTPrefetchModeNames[] = {
  "NONE",
  "HT_BUCKET"
};
const std::map<int, const char*> _TPrefetchMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTPrefetchModeValues, _kTPrefetchModeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TPrefetchMode::type& val) {
  std::map<int, const char*>::const_iterator it = _TPrefetchMode_VALUES_TO_NAMES.find(val);
  if (it != _TPrefetchMode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TPrefetchMode::type& val) {
  std::map<int, const char*>::const_iterator it = _TPrefetchMode_VALUES_TO_NAMES.find(val);
  if (it != _TPrefetchMode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTFunctionCategoryValues[] = {
  TFunctionCategory::SCALAR,
  TFunctionCategory::AGGREGATE,
  TFunctionCategory::ANALYTIC
};
const char* _kTFunctionCategoryNames[] = {
  "SCALAR",
  "AGGREGATE",
  "ANALYTIC"
};
const std::map<int, const char*> _TFunctionCategory_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTFunctionCategoryValues, _kTFunctionCategoryNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TFunctionCategory::type& val) {
  std::map<int, const char*>::const_iterator it = _TFunctionCategory_VALUES_TO_NAMES.find(val);
  if (it != _TFunctionCategory_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TFunctionCategory::type& val) {
  std::map<int, const char*>::const_iterator it = _TFunctionCategory_VALUES_TO_NAMES.find(val);
  if (it != _TFunctionCategory_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTFunctionBinaryTypeValues[] = {
  TFunctionBinaryType::BUILTIN,
  TFunctionBinaryType::JAVA,
  TFunctionBinaryType::NATIVE,
  TFunctionBinaryType::IR
};
const char* _kTFunctionBinaryTypeNames[] = {
  "BUILTIN",
  "JAVA",
  "NATIVE",
  "IR"
};
const std::map<int, const char*> _TFunctionBinaryType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTFunctionBinaryTypeValues, _kTFunctionBinaryTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TFunctionBinaryType::type& val) {
  std::map<int, const char*>::const_iterator it = _TFunctionBinaryType_VALUES_TO_NAMES.find(val);
  if (it != _TFunctionBinaryType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TFunctionBinaryType::type& val) {
  std::map<int, const char*>::const_iterator it = _TFunctionBinaryType_VALUES_TO_NAMES.find(val);
  if (it != _TFunctionBinaryType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTSortingOrderValues[] = {
  TSortingOrder::LEXICAL,
  TSortingOrder::ZORDER
};
const char* _kTSortingOrderNames[] = {
  "LEXICAL",
  "ZORDER"
};
const std::map<int, const char*> _TSortingOrder_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTSortingOrderValues, _kTSortingOrderNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TSortingOrder::type& val) {
  std::map<int, const char*>::const_iterator it = _TSortingOrder_VALUES_TO_NAMES.find(val);
  if (it != _TSortingOrder_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TSortingOrder::type& val) {
  std::map<int, const char*>::const_iterator it = _TSortingOrder_VALUES_TO_NAMES.find(val);
  if (it != _TSortingOrder_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


TScalarType::~TScalarType() noexcept {
}


void TScalarType::__set_type(const TPrimitiveType::type val) {
  this->type = val;
}

void TScalarType::__set_len(const int32_t val) {
  this->len = val;
__isset.len = true;
}

void TScalarType::__set_precision(const int32_t val) {
  this->precision = val;
__isset.precision = true;
}

void TScalarType::__set_scale(const int32_t val) {
  this->scale = val;
__isset.scale = true;
}
std::ostream& operator<<(std::ostream& out, const TScalarType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TScalarType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->type = static_cast<TPrimitiveType::type>(ecast0);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->len);
          this->__isset.len = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->precision);
          this->__isset.precision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->scale);
          this->__isset.scale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TScalarType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TScalarType");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->type));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.len) {
    xfer += oprot->writeFieldBegin("len", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->len);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.precision) {
    xfer += oprot->writeFieldBegin("precision", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->precision);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scale) {
    xfer += oprot->writeFieldBegin("scale", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->scale);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TScalarType &a, TScalarType &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.len, b.len);
  swap(a.precision, b.precision);
  swap(a.scale, b.scale);
  swap(a.__isset, b.__isset);
}

TScalarType::TScalarType(const TScalarType& other1) noexcept {
  type = other1.type;
  len = other1.len;
  precision = other1.precision;
  scale = other1.scale;
  __isset = other1.__isset;
}
TScalarType& TScalarType::operator=(const TScalarType& other2) noexcept {
  type = other2.type;
  len = other2.len;
  precision = other2.precision;
  scale = other2.scale;
  __isset = other2.__isset;
  return *this;
}
void TScalarType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TScalarType(";
  out << "type=" << to_string(type);
  out << ", " << "len="; (__isset.len ? (out << to_string(len)) : (out << "<null>"));
  out << ", " << "precision="; (__isset.precision ? (out << to_string(precision)) : (out << "<null>"));
  out << ", " << "scale="; (__isset.scale ? (out << to_string(scale)) : (out << "<null>"));
  out << ")";
}


TStructField::~TStructField() noexcept {
}


void TStructField::__set_name(const std::string& val) {
  this->name = val;
}

void TStructField::__set_comment(const std::string& val) {
  this->comment = val;
__isset.comment = true;
}

void TStructField::__set_field_id(const int32_t val) {
  this->field_id = val;
__isset.field_id = true;
}
std::ostream& operator<<(std::ostream& out, const TStructField& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TStructField::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field_id);
          this->__isset.field_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TStructField::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStructField");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.field_id) {
    xfer += oprot->writeFieldBegin("field_id", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->field_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStructField &a, TStructField &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.comment, b.comment);
  swap(a.field_id, b.field_id);
  swap(a.__isset, b.__isset);
}

TStructField::TStructField(const TStructField& other3) {
  name = other3.name;
  comment = other3.comment;
  field_id = other3.field_id;
  __isset = other3.__isset;
}
TStructField& TStructField::operator=(const TStructField& other4) {
  name = other4.name;
  comment = other4.comment;
  field_id = other4.field_id;
  __isset = other4.__isset;
  return *this;
}
void TStructField::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStructField(";
  out << "name=" << to_string(name);
  out << ", " << "comment="; (__isset.comment ? (out << to_string(comment)) : (out << "<null>"));
  out << ", " << "field_id="; (__isset.field_id ? (out << to_string(field_id)) : (out << "<null>"));
  out << ")";
}


TTypeNode::~TTypeNode() noexcept {
}


void TTypeNode::__set_type(const TTypeNodeType::type val) {
  this->type = val;
}

void TTypeNode::__set_scalar_type(const TScalarType& val) {
  this->scalar_type = val;
__isset.scalar_type = true;
}

void TTypeNode::__set_struct_fields(const std::vector<TStructField> & val) {
  this->struct_fields = val;
__isset.struct_fields = true;
}
std::ostream& operator<<(std::ostream& out, const TTypeNode& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTypeNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast5;
          xfer += iprot->readI32(ecast5);
          this->type = static_cast<TTypeNodeType::type>(ecast5);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scalar_type.read(iprot);
          this->__isset.scalar_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->struct_fields.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->struct_fields.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += this->struct_fields[_i10].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.struct_fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTypeNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTypeNode");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->type));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.scalar_type) {
    xfer += oprot->writeFieldBegin("scalar_type", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->scalar_type.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.struct_fields) {
    xfer += oprot->writeFieldBegin("struct_fields", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->struct_fields.size()));
      std::vector<TStructField> ::const_iterator _iter11;
      for (_iter11 = this->struct_fields.begin(); _iter11 != this->struct_fields.end(); ++_iter11)
      {
        xfer += (*_iter11).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTypeNode &a, TTypeNode &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.scalar_type, b.scalar_type);
  swap(a.struct_fields, b.struct_fields);
  swap(a.__isset, b.__isset);
}

TTypeNode::TTypeNode(const TTypeNode& other12) {
  type = other12.type;
  scalar_type = other12.scalar_type;
  struct_fields = other12.struct_fields;
  __isset = other12.__isset;
}
TTypeNode& TTypeNode::operator=(const TTypeNode& other13) {
  type = other13.type;
  scalar_type = other13.scalar_type;
  struct_fields = other13.struct_fields;
  __isset = other13.__isset;
  return *this;
}
void TTypeNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTypeNode(";
  out << "type=" << to_string(type);
  out << ", " << "scalar_type="; (__isset.scalar_type ? (out << to_string(scalar_type)) : (out << "<null>"));
  out << ", " << "struct_fields="; (__isset.struct_fields ? (out << to_string(struct_fields)) : (out << "<null>"));
  out << ")";
}


TColumnType::~TColumnType() noexcept {
}


void TColumnType::__set_types(const std::vector<TTypeNode> & val) {
  this->types = val;
}
std::ostream& operator<<(std::ostream& out, const TColumnType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumnType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->types.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->types.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              xfer += this->types[_i18].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumnType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnType");

  xfer += oprot->writeFieldBegin("types", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->types.size()));
    std::vector<TTypeNode> ::const_iterator _iter19;
    for (_iter19 = this->types.begin(); _iter19 != this->types.end(); ++_iter19)
    {
      xfer += (*_iter19).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnType &a, TColumnType &b) {
  using ::std::swap;
  swap(a.types, b.types);
  swap(a.__isset, b.__isset);
}

TColumnType::TColumnType(const TColumnType& other20) {
  types = other20.types;
  __isset = other20.__isset;
}
TColumnType& TColumnType::operator=(const TColumnType& other21) {
  types = other21.types;
  __isset = other21.__isset;
  return *this;
}
void TColumnType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnType(";
  out << "types=" << to_string(types);
  out << ")";
}


TNetworkAddress::~TNetworkAddress() noexcept {
}


void TNetworkAddress::__set_hostname(const std::string& val) {
  this->hostname = val;
}

void TNetworkAddress::__set_port(const int32_t val) {
  this->port = val;
}
std::ostream& operator<<(std::ostream& out, const TNetworkAddress& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TNetworkAddress::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_hostname = false;
  bool isset_port = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          isset_hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          isset_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_hostname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TNetworkAddress::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TNetworkAddress");

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TNetworkAddress &a, TNetworkAddress &b) {
  using ::std::swap;
  swap(a.hostname, b.hostname);
  swap(a.port, b.port);
}

TNetworkAddress::TNetworkAddress(const TNetworkAddress& other22) {
  hostname = other22.hostname;
  port = other22.port;
}
TNetworkAddress& TNetworkAddress::operator=(const TNetworkAddress& other23) {
  hostname = other23.hostname;
  port = other23.port;
  return *this;
}
void TNetworkAddress::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TNetworkAddress(";
  out << "hostname=" << to_string(hostname);
  out << ", " << "port=" << to_string(port);
  out << ")";
}


TUniqueId::~TUniqueId() noexcept {
}


void TUniqueId::__set_hi(const int64_t val) {
  this->hi = val;
}

void TUniqueId::__set_lo(const int64_t val) {
  this->lo = val;
}
std::ostream& operator<<(std::ostream& out, const TUniqueId& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TUniqueId::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_hi = false;
  bool isset_lo = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->hi);
          isset_hi = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lo);
          isset_lo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_hi)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_lo)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUniqueId::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUniqueId");

  xfer += oprot->writeFieldBegin("hi", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->hi);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lo", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->lo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUniqueId &a, TUniqueId &b) {
  using ::std::swap;
  swap(a.hi, b.hi);
  swap(a.lo, b.lo);
}

TUniqueId::TUniqueId(const TUniqueId& other24) noexcept {
  hi = other24.hi;
  lo = other24.lo;
}
TUniqueId& TUniqueId::operator=(const TUniqueId& other25) noexcept {
  hi = other25.hi;
  lo = other25.lo;
  return *this;
}
void TUniqueId::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUniqueId(";
  out << "hi=" << to_string(hi);
  out << ", " << "lo=" << to_string(lo);
  out << ")";
}


TFunctionName::~TFunctionName() noexcept {
}


void TFunctionName::__set_db_name(const std::string& val) {
  this->db_name = val;
__isset.db_name = true;
}

void TFunctionName::__set_function_name(const std::string& val) {
  this->function_name = val;
}
std::ostream& operator<<(std::ostream& out, const TFunctionName& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TFunctionName::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_function_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->function_name);
          isset_function_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_function_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFunctionName::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFunctionName");

  if (this->__isset.db_name) {
    xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->db_name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("function_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->function_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFunctionName &a, TFunctionName &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.function_name, b.function_name);
  swap(a.__isset, b.__isset);
}

TFunctionName::TFunctionName(const TFunctionName& other26) {
  db_name = other26.db_name;
  function_name = other26.function_name;
  __isset = other26.__isset;
}
TFunctionName& TFunctionName::operator=(const TFunctionName& other27) {
  db_name = other27.db_name;
  function_name = other27.function_name;
  __isset = other27.__isset;
  return *this;
}
void TFunctionName::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFunctionName(";
  out << "db_name="; (__isset.db_name ? (out << to_string(db_name)) : (out << "<null>"));
  out << ", " << "function_name=" << to_string(function_name);
  out << ")";
}


TScalarFunction::~TScalarFunction() noexcept {
}


void TScalarFunction::__set_symbol(const std::string& val) {
  this->symbol = val;
}

void TScalarFunction::__set_prepare_fn_symbol(const std::string& val) {
  this->prepare_fn_symbol = val;
__isset.prepare_fn_symbol = true;
}

void TScalarFunction::__set_close_fn_symbol(const std::string& val) {
  this->close_fn_symbol = val;
__isset.close_fn_symbol = true;
}
std::ostream& operator<<(std::ostream& out, const TScalarFunction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TScalarFunction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_symbol = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->symbol);
          isset_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->prepare_fn_symbol);
          this->__isset.prepare_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->close_fn_symbol);
          this->__isset.close_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_symbol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TScalarFunction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TScalarFunction");

  xfer += oprot->writeFieldBegin("symbol", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->symbol);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.prepare_fn_symbol) {
    xfer += oprot->writeFieldBegin("prepare_fn_symbol", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->prepare_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.close_fn_symbol) {
    xfer += oprot->writeFieldBegin("close_fn_symbol", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->close_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TScalarFunction &a, TScalarFunction &b) {
  using ::std::swap;
  swap(a.symbol, b.symbol);
  swap(a.prepare_fn_symbol, b.prepare_fn_symbol);
  swap(a.close_fn_symbol, b.close_fn_symbol);
  swap(a.__isset, b.__isset);
}

TScalarFunction::TScalarFunction(const TScalarFunction& other28) {
  symbol = other28.symbol;
  prepare_fn_symbol = other28.prepare_fn_symbol;
  close_fn_symbol = other28.close_fn_symbol;
  __isset = other28.__isset;
}
TScalarFunction& TScalarFunction::operator=(const TScalarFunction& other29) {
  symbol = other29.symbol;
  prepare_fn_symbol = other29.prepare_fn_symbol;
  close_fn_symbol = other29.close_fn_symbol;
  __isset = other29.__isset;
  return *this;
}
void TScalarFunction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TScalarFunction(";
  out << "symbol=" << to_string(symbol);
  out << ", " << "prepare_fn_symbol="; (__isset.prepare_fn_symbol ? (out << to_string(prepare_fn_symbol)) : (out << "<null>"));
  out << ", " << "close_fn_symbol="; (__isset.close_fn_symbol ? (out << to_string(close_fn_symbol)) : (out << "<null>"));
  out << ")";
}


TAggregateFunction::~TAggregateFunction() noexcept {
}


void TAggregateFunction::__set_intermediate_type(const TColumnType& val) {
  this->intermediate_type = val;
}

void TAggregateFunction::__set_is_analytic_only_fn(const bool val) {
  this->is_analytic_only_fn = val;
}

void TAggregateFunction::__set_update_fn_symbol(const std::string& val) {
  this->update_fn_symbol = val;
}

void TAggregateFunction::__set_init_fn_symbol(const std::string& val) {
  this->init_fn_symbol = val;
}

void TAggregateFunction::__set_serialize_fn_symbol(const std::string& val) {
  this->serialize_fn_symbol = val;
__isset.serialize_fn_symbol = true;
}

void TAggregateFunction::__set_merge_fn_symbol(const std::string& val) {
  this->merge_fn_symbol = val;
__isset.merge_fn_symbol = true;
}

void TAggregateFunction::__set_finalize_fn_symbol(const std::string& val) {
  this->finalize_fn_symbol = val;
__isset.finalize_fn_symbol = true;
}

void TAggregateFunction::__set_get_value_fn_symbol(const std::string& val) {
  this->get_value_fn_symbol = val;
__isset.get_value_fn_symbol = true;
}

void TAggregateFunction::__set_remove_fn_symbol(const std::string& val) {
  this->remove_fn_symbol = val;
__isset.remove_fn_symbol = true;
}

void TAggregateFunction::__set_ignores_distinct(const bool val) {
  this->ignores_distinct = val;
__isset.ignores_distinct = true;
}
std::ostream& operator<<(std::ostream& out, const TAggregateFunction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TAggregateFunction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_intermediate_type = false;
  bool isset_is_analytic_only_fn = false;
  bool isset_update_fn_symbol = false;
  bool isset_init_fn_symbol = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->intermediate_type.read(iprot);
          isset_intermediate_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_analytic_only_fn);
          isset_is_analytic_only_fn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->update_fn_symbol);
          isset_update_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->init_fn_symbol);
          isset_init_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serialize_fn_symbol);
          this->__isset.serialize_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->merge_fn_symbol);
          this->__isset.merge_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->finalize_fn_symbol);
          this->__isset.finalize_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->get_value_fn_symbol);
          this->__isset.get_value_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->remove_fn_symbol);
          this->__isset.remove_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ignores_distinct);
          this->__isset.ignores_distinct = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_intermediate_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_analytic_only_fn)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_update_fn_symbol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_init_fn_symbol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAggregateFunction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAggregateFunction");

  xfer += oprot->writeFieldBegin("intermediate_type", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->intermediate_type.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_analytic_only_fn", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_analytic_only_fn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_fn_symbol", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->update_fn_symbol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("init_fn_symbol", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->init_fn_symbol);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.serialize_fn_symbol) {
    xfer += oprot->writeFieldBegin("serialize_fn_symbol", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->serialize_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.merge_fn_symbol) {
    xfer += oprot->writeFieldBegin("merge_fn_symbol", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->merge_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.finalize_fn_symbol) {
    xfer += oprot->writeFieldBegin("finalize_fn_symbol", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->finalize_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.get_value_fn_symbol) {
    xfer += oprot->writeFieldBegin("get_value_fn_symbol", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->get_value_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.remove_fn_symbol) {
    xfer += oprot->writeFieldBegin("remove_fn_symbol", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->remove_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ignores_distinct) {
    xfer += oprot->writeFieldBegin("ignores_distinct", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->ignores_distinct);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAggregateFunction &a, TAggregateFunction &b) {
  using ::std::swap;
  swap(a.intermediate_type, b.intermediate_type);
  swap(a.is_analytic_only_fn, b.is_analytic_only_fn);
  swap(a.update_fn_symbol, b.update_fn_symbol);
  swap(a.init_fn_symbol, b.init_fn_symbol);
  swap(a.serialize_fn_symbol, b.serialize_fn_symbol);
  swap(a.merge_fn_symbol, b.merge_fn_symbol);
  swap(a.finalize_fn_symbol, b.finalize_fn_symbol);
  swap(a.get_value_fn_symbol, b.get_value_fn_symbol);
  swap(a.remove_fn_symbol, b.remove_fn_symbol);
  swap(a.ignores_distinct, b.ignores_distinct);
  swap(a.__isset, b.__isset);
}

TAggregateFunction::TAggregateFunction(const TAggregateFunction& other30) {
  intermediate_type = other30.intermediate_type;
  is_analytic_only_fn = other30.is_analytic_only_fn;
  update_fn_symbol = other30.update_fn_symbol;
  init_fn_symbol = other30.init_fn_symbol;
  serialize_fn_symbol = other30.serialize_fn_symbol;
  merge_fn_symbol = other30.merge_fn_symbol;
  finalize_fn_symbol = other30.finalize_fn_symbol;
  get_value_fn_symbol = other30.get_value_fn_symbol;
  remove_fn_symbol = other30.remove_fn_symbol;
  ignores_distinct = other30.ignores_distinct;
  __isset = other30.__isset;
}
TAggregateFunction& TAggregateFunction::operator=(const TAggregateFunction& other31) {
  intermediate_type = other31.intermediate_type;
  is_analytic_only_fn = other31.is_analytic_only_fn;
  update_fn_symbol = other31.update_fn_symbol;
  init_fn_symbol = other31.init_fn_symbol;
  serialize_fn_symbol = other31.serialize_fn_symbol;
  merge_fn_symbol = other31.merge_fn_symbol;
  finalize_fn_symbol = other31.finalize_fn_symbol;
  get_value_fn_symbol = other31.get_value_fn_symbol;
  remove_fn_symbol = other31.remove_fn_symbol;
  ignores_distinct = other31.ignores_distinct;
  __isset = other31.__isset;
  return *this;
}
void TAggregateFunction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAggregateFunction(";
  out << "intermediate_type=" << to_string(intermediate_type);
  out << ", " << "is_analytic_only_fn=" << to_string(is_analytic_only_fn);
  out << ", " << "update_fn_symbol=" << to_string(update_fn_symbol);
  out << ", " << "init_fn_symbol=" << to_string(init_fn_symbol);
  out << ", " << "serialize_fn_symbol="; (__isset.serialize_fn_symbol ? (out << to_string(serialize_fn_symbol)) : (out << "<null>"));
  out << ", " << "merge_fn_symbol="; (__isset.merge_fn_symbol ? (out << to_string(merge_fn_symbol)) : (out << "<null>"));
  out << ", " << "finalize_fn_symbol="; (__isset.finalize_fn_symbol ? (out << to_string(finalize_fn_symbol)) : (out << "<null>"));
  out << ", " << "get_value_fn_symbol="; (__isset.get_value_fn_symbol ? (out << to_string(get_value_fn_symbol)) : (out << "<null>"));
  out << ", " << "remove_fn_symbol="; (__isset.remove_fn_symbol ? (out << to_string(remove_fn_symbol)) : (out << "<null>"));
  out << ", " << "ignores_distinct="; (__isset.ignores_distinct ? (out << to_string(ignores_distinct)) : (out << "<null>"));
  out << ")";
}


TFunction::~TFunction() noexcept {
}


void TFunction::__set_name(const TFunctionName& val) {
  this->name = val;
}

void TFunction::__set_binary_type(const TFunctionBinaryType::type val) {
  this->binary_type = val;
__isset.binary_type = true;
}

void TFunction::__set_arg_types(const std::vector<TColumnType> & val) {
  this->arg_types = val;
__isset.arg_types = true;
}

void TFunction::__set_ret_type(const TColumnType& val) {
  this->ret_type = val;
__isset.ret_type = true;
}

void TFunction::__set_has_var_args(const bool val) {
  this->has_var_args = val;
__isset.has_var_args = true;
}

void TFunction::__set_comment(const std::string& val) {
  this->comment = val;
__isset.comment = true;
}

void TFunction::__set_signature(const std::string& val) {
  this->signature = val;
__isset.signature = true;
}

void TFunction::__set_hdfs_location(const std::string& val) {
  this->hdfs_location = val;
__isset.hdfs_location = true;
}

void TFunction::__set_scalar_fn(const TScalarFunction& val) {
  this->scalar_fn = val;
__isset.scalar_fn = true;
}

void TFunction::__set_aggregate_fn(const TAggregateFunction& val) {
  this->aggregate_fn = val;
__isset.aggregate_fn = true;
}

void TFunction::__set_is_persistent(const bool val) {
  this->is_persistent = val;
__isset.is_persistent = true;
}

void TFunction::__set_last_modified_time(const int64_t val) {
  this->last_modified_time = val;
__isset.last_modified_time = true;
}
std::ostream& operator<<(std::ostream& out, const TFunction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TFunction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->name.read(iprot);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast32;
          xfer += iprot->readI32(ecast32);
          this->binary_type = static_cast<TFunctionBinaryType::type>(ecast32);
          this->__isset.binary_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arg_types.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _etype36;
            xfer += iprot->readListBegin(_etype36, _size33);
            this->arg_types.resize(_size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              xfer += this->arg_types[_i37].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.arg_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ret_type.read(iprot);
          this->__isset.ret_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_var_args);
          this->__isset.has_var_args = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->signature);
          this->__isset.signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hdfs_location);
          this->__isset.hdfs_location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scalar_fn.read(iprot);
          this->__isset.scalar_fn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->aggregate_fn.read(iprot);
          this->__isset.aggregate_fn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_persistent);
          this->__isset.is_persistent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_modified_time);
          this->__isset.last_modified_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFunction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFunction");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->name.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.binary_type) {
    xfer += oprot->writeFieldBegin("binary_type", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(static_cast<int32_t>(this->binary_type));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.arg_types) {
    xfer += oprot->writeFieldBegin("arg_types", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->arg_types.size()));
      std::vector<TColumnType> ::const_iterator _iter38;
      for (_iter38 = this->arg_types.begin(); _iter38 != this->arg_types.end(); ++_iter38)
      {
        xfer += (*_iter38).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ret_type) {
    xfer += oprot->writeFieldBegin("ret_type", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->ret_type.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.has_var_args) {
    xfer += oprot->writeFieldBegin("has_var_args", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->has_var_args);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.signature) {
    xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->signature);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hdfs_location) {
    xfer += oprot->writeFieldBegin("hdfs_location", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->hdfs_location);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scalar_fn) {
    xfer += oprot->writeFieldBegin("scalar_fn", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->scalar_fn.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.aggregate_fn) {
    xfer += oprot->writeFieldBegin("aggregate_fn", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->aggregate_fn.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_persistent) {
    xfer += oprot->writeFieldBegin("is_persistent", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->is_persistent);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.last_modified_time) {
    xfer += oprot->writeFieldBegin("last_modified_time", ::apache::thrift::protocol::T_I64, 12);
    xfer += oprot->writeI64(this->last_modified_time);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFunction &a, TFunction &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.binary_type, b.binary_type);
  swap(a.arg_types, b.arg_types);
  swap(a.ret_type, b.ret_type);
  swap(a.has_var_args, b.has_var_args);
  swap(a.comment, b.comment);
  swap(a.signature, b.signature);
  swap(a.hdfs_location, b.hdfs_location);
  swap(a.scalar_fn, b.scalar_fn);
  swap(a.aggregate_fn, b.aggregate_fn);
  swap(a.is_persistent, b.is_persistent);
  swap(a.last_modified_time, b.last_modified_time);
  swap(a.__isset, b.__isset);
}

TFunction::TFunction(const TFunction& other39) {
  name = other39.name;
  binary_type = other39.binary_type;
  arg_types = other39.arg_types;
  ret_type = other39.ret_type;
  has_var_args = other39.has_var_args;
  comment = other39.comment;
  signature = other39.signature;
  hdfs_location = other39.hdfs_location;
  scalar_fn = other39.scalar_fn;
  aggregate_fn = other39.aggregate_fn;
  is_persistent = other39.is_persistent;
  last_modified_time = other39.last_modified_time;
  __isset = other39.__isset;
}
TFunction& TFunction::operator=(const TFunction& other40) {
  name = other40.name;
  binary_type = other40.binary_type;
  arg_types = other40.arg_types;
  ret_type = other40.ret_type;
  has_var_args = other40.has_var_args;
  comment = other40.comment;
  signature = other40.signature;
  hdfs_location = other40.hdfs_location;
  scalar_fn = other40.scalar_fn;
  aggregate_fn = other40.aggregate_fn;
  is_persistent = other40.is_persistent;
  last_modified_time = other40.last_modified_time;
  __isset = other40.__isset;
  return *this;
}
void TFunction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFunction(";
  out << "name=" << to_string(name);
  out << ", " << "binary_type="; (__isset.binary_type ? (out << to_string(binary_type)) : (out << "<null>"));
  out << ", " << "arg_types="; (__isset.arg_types ? (out << to_string(arg_types)) : (out << "<null>"));
  out << ", " << "ret_type="; (__isset.ret_type ? (out << to_string(ret_type)) : (out << "<null>"));
  out << ", " << "has_var_args="; (__isset.has_var_args ? (out << to_string(has_var_args)) : (out << "<null>"));
  out << ", " << "comment="; (__isset.comment ? (out << to_string(comment)) : (out << "<null>"));
  out << ", " << "signature="; (__isset.signature ? (out << to_string(signature)) : (out << "<null>"));
  out << ", " << "hdfs_location="; (__isset.hdfs_location ? (out << to_string(hdfs_location)) : (out << "<null>"));
  out << ", " << "scalar_fn="; (__isset.scalar_fn ? (out << to_string(scalar_fn)) : (out << "<null>"));
  out << ", " << "aggregate_fn="; (__isset.aggregate_fn ? (out << to_string(aggregate_fn)) : (out << "<null>"));
  out << ", " << "is_persistent="; (__isset.is_persistent ? (out << to_string(is_persistent)) : (out << "<null>"));
  out << ", " << "last_modified_time="; (__isset.last_modified_time ? (out << to_string(last_modified_time)) : (out << "<null>"));
  out << ")";
}

} // namespace
