/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "ExecStats_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace impala {

int _kTExecStateValues[] = {
  TExecState::REGISTERED,
  TExecState::PLANNING,
  TExecState::QUEUED,
  TExecState::RUNNING,
  TExecState::FINISHED,
  TExecState::CANCELLED,
  TExecState::FAILED
};
const char* _kTExecStateNames[] = {
  "REGISTERED",
  "PLANNING",
  "QUEUED",
  "RUNNING",
  "FINISHED",
  "CANCELLED",
  "FAILED"
};
const std::map<int, const char*> _TExecState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kTExecStateValues, _kTExecStateNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TExecState::type& val) {
  std::map<int, const char*>::const_iterator it = _TExecState_VALUES_TO_NAMES.find(val);
  if (it != _TExecState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TExecState::type& val) {
  std::map<int, const char*>::const_iterator it = _TExecState_VALUES_TO_NAMES.find(val);
  if (it != _TExecState_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


TExecStats::~TExecStats() noexcept {
}


void TExecStats::__set_latency_ns(const int64_t val) {
  this->latency_ns = val;
__isset.latency_ns = true;
}

void TExecStats::__set_cpu_time_ns(const int64_t val) {
  this->cpu_time_ns = val;
__isset.cpu_time_ns = true;
}

void TExecStats::__set_cardinality(const int64_t val) {
  this->cardinality = val;
__isset.cardinality = true;
}

void TExecStats::__set_memory_used(const int64_t val) {
  this->memory_used = val;
__isset.memory_used = true;
}
std::ostream& operator<<(std::ostream& out, const TExecStats& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TExecStats::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->latency_ns);
          this->__isset.latency_ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cpu_time_ns);
          this->__isset.cpu_time_ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cardinality);
          this->__isset.cardinality = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->memory_used);
          this->__isset.memory_used = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TExecStats::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExecStats");

  if (this->__isset.latency_ns) {
    xfer += oprot->writeFieldBegin("latency_ns", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->latency_ns);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cpu_time_ns) {
    xfer += oprot->writeFieldBegin("cpu_time_ns", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->cpu_time_ns);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cardinality) {
    xfer += oprot->writeFieldBegin("cardinality", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->cardinality);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.memory_used) {
    xfer += oprot->writeFieldBegin("memory_used", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->memory_used);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExecStats &a, TExecStats &b) {
  using ::std::swap;
  swap(a.latency_ns, b.latency_ns);
  swap(a.cpu_time_ns, b.cpu_time_ns);
  swap(a.cardinality, b.cardinality);
  swap(a.memory_used, b.memory_used);
  swap(a.__isset, b.__isset);
}

TExecStats::TExecStats(const TExecStats& other0) noexcept {
  latency_ns = other0.latency_ns;
  cpu_time_ns = other0.cpu_time_ns;
  cardinality = other0.cardinality;
  memory_used = other0.memory_used;
  __isset = other0.__isset;
}
TExecStats& TExecStats::operator=(const TExecStats& other1) noexcept {
  latency_ns = other1.latency_ns;
  cpu_time_ns = other1.cpu_time_ns;
  cardinality = other1.cardinality;
  memory_used = other1.memory_used;
  __isset = other1.__isset;
  return *this;
}
void TExecStats::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TExecStats(";
  out << "latency_ns="; (__isset.latency_ns ? (out << to_string(latency_ns)) : (out << "<null>"));
  out << ", " << "cpu_time_ns="; (__isset.cpu_time_ns ? (out << to_string(cpu_time_ns)) : (out << "<null>"));
  out << ", " << "cardinality="; (__isset.cardinality ? (out << to_string(cardinality)) : (out << "<null>"));
  out << ", " << "memory_used="; (__isset.memory_used ? (out << to_string(memory_used)) : (out << "<null>"));
  out << ")";
}


TPlanNodeExecSummary::~TPlanNodeExecSummary() noexcept {
}


void TPlanNodeExecSummary::__set_node_id(const  ::impala::TPlanNodeId val) {
  this->node_id = val;
}

void TPlanNodeExecSummary::__set_fragment_idx(const  ::impala::TFragmentIdx val) {
  this->fragment_idx = val;
}

void TPlanNodeExecSummary::__set_label(const std::string& val) {
  this->label = val;
}

void TPlanNodeExecSummary::__set_label_detail(const std::string& val) {
  this->label_detail = val;
__isset.label_detail = true;
}

void TPlanNodeExecSummary::__set_num_children(const int32_t val) {
  this->num_children = val;
}

void TPlanNodeExecSummary::__set_estimated_stats(const TExecStats& val) {
  this->estimated_stats = val;
__isset.estimated_stats = true;
}

void TPlanNodeExecSummary::__set_exec_stats(const std::vector<TExecStats> & val) {
  this->exec_stats = val;
__isset.exec_stats = true;
}

void TPlanNodeExecSummary::__set_is_broadcast(const bool val) {
  this->is_broadcast = val;
__isset.is_broadcast = true;
}

void TPlanNodeExecSummary::__set_num_hosts(const int32_t val) {
  this->num_hosts = val;
__isset.num_hosts = true;
}
std::ostream& operator<<(std::ostream& out, const TPlanNodeExecSummary& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPlanNodeExecSummary::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_node_id = false;
  bool isset_fragment_idx = false;
  bool isset_label = false;
  bool isset_num_children = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_id);
          isset_node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fragment_idx);
          isset_fragment_idx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->label);
          isset_label = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->label_detail);
          this->__isset.label_detail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_children);
          isset_num_children = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->estimated_stats.read(iprot);
          this->__isset.estimated_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->exec_stats.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->exec_stats.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += this->exec_stats[_i6].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.exec_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_broadcast);
          this->__isset.is_broadcast = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_hosts);
          this->__isset.num_hosts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_node_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fragment_idx)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_label)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_children)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPlanNodeExecSummary::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPlanNodeExecSummary");

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fragment_idx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->fragment_idx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("label", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->label);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.label_detail) {
    xfer += oprot->writeFieldBegin("label_detail", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->label_detail);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("num_children", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->num_children);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.estimated_stats) {
    xfer += oprot->writeFieldBegin("estimated_stats", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->estimated_stats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exec_stats) {
    xfer += oprot->writeFieldBegin("exec_stats", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->exec_stats.size()));
      std::vector<TExecStats> ::const_iterator _iter7;
      for (_iter7 = this->exec_stats.begin(); _iter7 != this->exec_stats.end(); ++_iter7)
      {
        xfer += (*_iter7).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_broadcast) {
    xfer += oprot->writeFieldBegin("is_broadcast", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_broadcast);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num_hosts) {
    xfer += oprot->writeFieldBegin("num_hosts", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->num_hosts);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPlanNodeExecSummary &a, TPlanNodeExecSummary &b) {
  using ::std::swap;
  swap(a.node_id, b.node_id);
  swap(a.fragment_idx, b.fragment_idx);
  swap(a.label, b.label);
  swap(a.label_detail, b.label_detail);
  swap(a.num_children, b.num_children);
  swap(a.estimated_stats, b.estimated_stats);
  swap(a.exec_stats, b.exec_stats);
  swap(a.is_broadcast, b.is_broadcast);
  swap(a.num_hosts, b.num_hosts);
  swap(a.__isset, b.__isset);
}

TPlanNodeExecSummary::TPlanNodeExecSummary(const TPlanNodeExecSummary& other8) {
  node_id = other8.node_id;
  fragment_idx = other8.fragment_idx;
  label = other8.label;
  label_detail = other8.label_detail;
  num_children = other8.num_children;
  estimated_stats = other8.estimated_stats;
  exec_stats = other8.exec_stats;
  is_broadcast = other8.is_broadcast;
  num_hosts = other8.num_hosts;
  __isset = other8.__isset;
}
TPlanNodeExecSummary& TPlanNodeExecSummary::operator=(const TPlanNodeExecSummary& other9) {
  node_id = other9.node_id;
  fragment_idx = other9.fragment_idx;
  label = other9.label;
  label_detail = other9.label_detail;
  num_children = other9.num_children;
  estimated_stats = other9.estimated_stats;
  exec_stats = other9.exec_stats;
  is_broadcast = other9.is_broadcast;
  num_hosts = other9.num_hosts;
  __isset = other9.__isset;
  return *this;
}
void TPlanNodeExecSummary::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPlanNodeExecSummary(";
  out << "node_id=" << to_string(node_id);
  out << ", " << "fragment_idx=" << to_string(fragment_idx);
  out << ", " << "label=" << to_string(label);
  out << ", " << "label_detail="; (__isset.label_detail ? (out << to_string(label_detail)) : (out << "<null>"));
  out << ", " << "num_children=" << to_string(num_children);
  out << ", " << "estimated_stats="; (__isset.estimated_stats ? (out << to_string(estimated_stats)) : (out << "<null>"));
  out << ", " << "exec_stats="; (__isset.exec_stats ? (out << to_string(exec_stats)) : (out << "<null>"));
  out << ", " << "is_broadcast="; (__isset.is_broadcast ? (out << to_string(is_broadcast)) : (out << "<null>"));
  out << ", " << "num_hosts="; (__isset.num_hosts ? (out << to_string(num_hosts)) : (out << "<null>"));
  out << ")";
}


TExecProgress::~TExecProgress() noexcept {
}


void TExecProgress::__set_total_scan_ranges(const int64_t val) {
  this->total_scan_ranges = val;
__isset.total_scan_ranges = true;
}

void TExecProgress::__set_num_completed_scan_ranges(const int64_t val) {
  this->num_completed_scan_ranges = val;
__isset.num_completed_scan_ranges = true;
}
std::ostream& operator<<(std::ostream& out, const TExecProgress& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TExecProgress::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_scan_ranges);
          this->__isset.total_scan_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_completed_scan_ranges);
          this->__isset.num_completed_scan_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TExecProgress::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExecProgress");

  if (this->__isset.total_scan_ranges) {
    xfer += oprot->writeFieldBegin("total_scan_ranges", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->total_scan_ranges);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num_completed_scan_ranges) {
    xfer += oprot->writeFieldBegin("num_completed_scan_ranges", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->num_completed_scan_ranges);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExecProgress &a, TExecProgress &b) {
  using ::std::swap;
  swap(a.total_scan_ranges, b.total_scan_ranges);
  swap(a.num_completed_scan_ranges, b.num_completed_scan_ranges);
  swap(a.__isset, b.__isset);
}

TExecProgress::TExecProgress(const TExecProgress& other10) noexcept {
  total_scan_ranges = other10.total_scan_ranges;
  num_completed_scan_ranges = other10.num_completed_scan_ranges;
  __isset = other10.__isset;
}
TExecProgress& TExecProgress::operator=(const TExecProgress& other11) noexcept {
  total_scan_ranges = other11.total_scan_ranges;
  num_completed_scan_ranges = other11.num_completed_scan_ranges;
  __isset = other11.__isset;
  return *this;
}
void TExecProgress::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TExecProgress(";
  out << "total_scan_ranges="; (__isset.total_scan_ranges ? (out << to_string(total_scan_ranges)) : (out << "<null>"));
  out << ", " << "num_completed_scan_ranges="; (__isset.num_completed_scan_ranges ? (out << to_string(num_completed_scan_ranges)) : (out << "<null>"));
  out << ")";
}


TExecSummary::~TExecSummary() noexcept {
}


void TExecSummary::__set_state(const TExecState::type val) {
  this->state = val;
}

void TExecSummary::__set_status(const  ::impala::TStatus& val) {
  this->status = val;
__isset.status = true;
}

void TExecSummary::__set_nodes(const std::vector<TPlanNodeExecSummary> & val) {
  this->nodes = val;
__isset.nodes = true;
}

void TExecSummary::__set_exch_to_sender_map(const std::map<int32_t, int32_t> & val) {
  this->exch_to_sender_map = val;
__isset.exch_to_sender_map = true;
}

void TExecSummary::__set_error_logs(const std::vector<std::string> & val) {
  this->error_logs = val;
__isset.error_logs = true;
}

void TExecSummary::__set_progress(const TExecProgress& val) {
  this->progress = val;
__isset.progress = true;
}

void TExecSummary::__set_is_queued(const bool val) {
  this->is_queued = val;
__isset.is_queued = true;
}

void TExecSummary::__set_queued_reason(const std::string& val) {
  this->queued_reason = val;
__isset.queued_reason = true;
}
std::ostream& operator<<(std::ostream& out, const TExecSummary& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TExecSummary::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_state = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast12;
          xfer += iprot->readI32(ecast12);
          this->state = static_cast<TExecState::type>(ecast12);
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nodes.clear();
            uint32_t _size13;
            ::apache::thrift::protocol::TType _etype16;
            xfer += iprot->readListBegin(_etype16, _size13);
            this->nodes.resize(_size13);
            uint32_t _i17;
            for (_i17 = 0; _i17 < _size13; ++_i17)
            {
              xfer += this->nodes[_i17].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->exch_to_sender_map.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _ktype19;
            ::apache::thrift::protocol::TType _vtype20;
            xfer += iprot->readMapBegin(_ktype19, _vtype20, _size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              int32_t _key23;
              xfer += iprot->readI32(_key23);
              int32_t& _val24 = this->exch_to_sender_map[_key23];
              xfer += iprot->readI32(_val24);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.exch_to_sender_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->error_logs.clear();
            uint32_t _size25;
            ::apache::thrift::protocol::TType _etype28;
            xfer += iprot->readListBegin(_etype28, _size25);
            this->error_logs.resize(_size25);
            uint32_t _i29;
            for (_i29 = 0; _i29 < _size25; ++_i29)
            {
              xfer += iprot->readString(this->error_logs[_i29]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.error_logs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->progress.read(iprot);
          this->__isset.progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_queued);
          this->__isset.is_queued = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->queued_reason);
          this->__isset.queued_reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExecSummary::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExecSummary");

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->state));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nodes) {
    xfer += oprot->writeFieldBegin("nodes", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->nodes.size()));
      std::vector<TPlanNodeExecSummary> ::const_iterator _iter30;
      for (_iter30 = this->nodes.begin(); _iter30 != this->nodes.end(); ++_iter30)
      {
        xfer += (*_iter30).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exch_to_sender_map) {
    xfer += oprot->writeFieldBegin("exch_to_sender_map", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->exch_to_sender_map.size()));
      std::map<int32_t, int32_t> ::const_iterator _iter31;
      for (_iter31 = this->exch_to_sender_map.begin(); _iter31 != this->exch_to_sender_map.end(); ++_iter31)
      {
        xfer += oprot->writeI32(_iter31->first);
        xfer += oprot->writeI32(_iter31->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.error_logs) {
    xfer += oprot->writeFieldBegin("error_logs", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->error_logs.size()));
      std::vector<std::string> ::const_iterator _iter32;
      for (_iter32 = this->error_logs.begin(); _iter32 != this->error_logs.end(); ++_iter32)
      {
        xfer += oprot->writeString((*_iter32));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.progress) {
    xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->progress.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_queued) {
    xfer += oprot->writeFieldBegin("is_queued", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_queued);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.queued_reason) {
    xfer += oprot->writeFieldBegin("queued_reason", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->queued_reason);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExecSummary &a, TExecSummary &b) {
  using ::std::swap;
  swap(a.state, b.state);
  swap(a.status, b.status);
  swap(a.nodes, b.nodes);
  swap(a.exch_to_sender_map, b.exch_to_sender_map);
  swap(a.error_logs, b.error_logs);
  swap(a.progress, b.progress);
  swap(a.is_queued, b.is_queued);
  swap(a.queued_reason, b.queued_reason);
  swap(a.__isset, b.__isset);
}

TExecSummary::TExecSummary(const TExecSummary& other33) {
  state = other33.state;
  status = other33.status;
  nodes = other33.nodes;
  exch_to_sender_map = other33.exch_to_sender_map;
  error_logs = other33.error_logs;
  progress = other33.progress;
  is_queued = other33.is_queued;
  queued_reason = other33.queued_reason;
  __isset = other33.__isset;
}
TExecSummary& TExecSummary::operator=(const TExecSummary& other34) {
  state = other34.state;
  status = other34.status;
  nodes = other34.nodes;
  exch_to_sender_map = other34.exch_to_sender_map;
  error_logs = other34.error_logs;
  progress = other34.progress;
  is_queued = other34.is_queued;
  queued_reason = other34.queued_reason;
  __isset = other34.__isset;
  return *this;
}
void TExecSummary::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TExecSummary(";
  out << "state=" << to_string(state);
  out << ", " << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ", " << "nodes="; (__isset.nodes ? (out << to_string(nodes)) : (out << "<null>"));
  out << ", " << "exch_to_sender_map="; (__isset.exch_to_sender_map ? (out << to_string(exch_to_sender_map)) : (out << "<null>"));
  out << ", " << "error_logs="; (__isset.error_logs ? (out << to_string(error_logs)) : (out << "<null>"));
  out << ", " << "progress="; (__isset.progress ? (out << to_string(progress)) : (out << "<null>"));
  out << ", " << "is_queued="; (__isset.is_queued ? (out << to_string(is_queued)) : (out << "<null>"));
  out << ", " << "queued_reason="; (__isset.queued_reason ? (out << to_string(queued_reason)) : (out << "<null>"));
  out << ")";
}

} // namespace
